--
--  Donor Segment
--
CREATE TABLE IF NOT EXISTS donor_seg (
    id                   BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name                 TEXT NOT NULL,
    description          TEXT
)
WITH (FILLFACTOR=70);

--
--  Donor Segment Members (composed of "donor" `indiv` records)
--
CREATE TABLE IF NOT EXISTS donor_seg_memb (
    id                   BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    donor_seg_id         BIGINT NOT NULL,
    donor_indiv_id       BIGINT NOT NULL
)
WITH (FILLFACTOR=70);

ALTER TABLE donor_seg_memb ADD FOREIGN KEY (donor_seg_id)   REFERENCES donor_seg (id) ON DELETE CASCADE;
ALTER TABLE donor_seg_memb ADD FOREIGN KEY (donor_indiv_id) REFERENCES indiv (id);

CREATE UNIQUE INDEX donor_seg_name          ON donor_seg (name);
CREATE UNIQUE INDEX donor_seg_memb_user_key ON donor_seg_memb (donor_seg_id, donor_indiv_id);
CREATE INDEX donor_seg_memb_donor_indiv_id  ON donor_seg_memb (donor_indiv_id);

/*
 *  Need to create a custom type to represent a set of ids, since postgres does not support
 *  BIGINT[][], where inner array has variable size; this type enables the following pattern
 *  (used below): array[row(array[<ids>])::id_array]
 */
CREATE TYPE id_array AS (ids BIGINT[]);

/*
 *  Create a donor segment based on set of donor designations (each of which is an `id_array`
 *  with the `indiv` ids for the donor)
 *
 *  Args:
 *    donor_rows - a doner record will be "created" for each input row (i.e. the underlying
 *                 `indiv` ids will be collectively associated), and all donors in the set
 *                 will be added to the segment
 *    seg_name   - name of the segment to create
 *    seg_desc   - description of segment (optional)
 *
 *  Notes:
 *    - the target table for individual records is parameterized (here, and in `set_donor_indiv`
 *      to allow for management of multiple representations (e.g. aggregation algorithms) of the
 *      individual/donor "master"
 */
CREATE OR REPLACE FUNCTION create_donor_seg(donor_rows id_array[], seg_name text, seg_desc text = null)
RETURNS BIGINT AS $$
DECLARE
indiv_tbl TEXT = 'indiv';
seg_id    BIGINT;
donor_id  BIGINT;
donor_ids id_array;
BEGIN
    EXECUTE 'insert into donor_seg (name, description)
             values ($1, $2)
             on conflict do nothing
             returning id'
    INTO seg_id
    USING seg_name, seg_desc;

    FOREACH donor_ids IN ARRAY donor_rows
    LOOP
        EXECUTE 'select set_donor_indiv($1, $2)'
        INTO donor_id
        USING indiv_tbl, donor_ids.ids;

        EXECUTE
            'insert into donor_seg_memb(donor_seg_id, donor_indiv_id)
             values ($1, $2)
             on conflict do nothing'
        USING seg_id, donor_id;
    END LOOP;
    RETURN seg_id;
END;
$$ LANGUAGE plpgsql;
